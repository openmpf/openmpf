/******************************************************************************
 * NOTICE                                                                     *
 *                                                                            *
 * This software (or technical data) was produced for the U.S. Government     *
 * under contract, and is subject to the Rights in Data-General Clause        *
 * 52.227-14, Alt. IV (DEC 2007).                                             *
 *                                                                            *
 * Copyright 2023 The MITRE Corporation. All Rights Reserved.                 *
 ******************************************************************************/

/******************************************************************************
 * Copyright 2023 The MITRE Corporation                                       *
 *                                                                            *
 * Licensed under the Apache License, Version 2.0 (the "License");            *
 * you may not use this file except in compliance with the License.           *
 * You may obtain a copy of the License at                                    *
 *                                                                            *
 *    http://www.apache.org/licenses/LICENSE-2.0                              *
 *                                                                            *
 * Unless required by applicable law or agreed to in writing, software        *
 * distributed under the License is distributed on an "AS IS" BASIS,          *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
 * See the License for the specific language governing permissions and        *
 * limitations under the License.                                             *
 ******************************************************************************/

package org.mitre.mpf.mvc.controller;

import java.util.Map;

import jakarta.inject.Inject;

import org.atmosphere.config.service.ManagedService;
import org.atmosphere.config.service.Message;
import org.atmosphere.cpr.AtmosphereResource;
import org.atmosphere.cpr.Broadcaster;
import org.atmosphere.cpr.BroadcasterFactory;
import org.atmosphere.cpr.PerRequestBroadcastFilter;
import org.mitre.mpf.mvc.JacksonEncoder;
import org.mitre.mpf.mvc.model.AtmosphereChannel;
import org.mitre.mpf.mvc.model.AtmosphereMessage;
import org.mitre.mpf.mvc.model.JobStatusMessage;
import org.mitre.mpf.mvc.util.SessionUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *  Workflow manager uses Atmosphere (https://github.com/Atmosphere/atmosphere) for asynchronous communication
 *  to clients, referred to here as Server Side Push.  This is an event-based approach where
 *  events are generated by workflow-manager, packaged as AtmosphereMessage messages, and broadcasted to all
 *  logged in clients.  The Atmosphere package prefers websockets as the underlying mechanism for communication,
 *  but will intelligently downgrade to comet and other mechanisms if the client does not support websockets.
 *
 *  This approach simplifies and unifies messaging from server to client, provides for a consistent messaging bundle
 *  among components, and significantly decreases the network traffic when using modern browsers.
 *
 *  Workflow manager messages are divided into channels, as specified in
 *  org.mitre.mpf.mvc.model.AtmosphereChannel.  Clients use $on(...) handlers to react to server notifications.
 *
 *  An AtmosphereMessage looks like the following (in JSON)
 *		{
 *			"channel": "SSPC_ATMOSPHERE",
 *			"event": "OnConnected",
 *			"timestamp": 1453350363907,
 *			"content": {
 *				"abc": "1",
 *				"xyz": "2"
 *			}
 *		}
 *	Note that the content can be any arbitrary Java HashMap, making it easy to encode any data as key/value pairs.
 *	Typical for JSON messaging, each message author designs her own semantics for the message content, and
 *	each client will need to understand the intended semantic.
 *
 *  The reason that we have channels and then events in the channels, instead of events directly
 *  is that this promotes events that have more consistent semantic meaning among its peers in the same channel.
 *  Also, it enables similar code to be contained within the same handler on the client side.
 *
 *  However, not all channels have events (e.g., SSPC_HEARTBEAT) so you should check for null first when accessing events.
 *
 */
@ManagedService(path = "/") //points to websocket/ seen in web.xml
public class AtmosphereController {
	private static final Logger logger = LoggerFactory.getLogger(AtmosphereController.class);

	@Inject
	private static BroadcasterFactory staticFactory;

	private static boolean _filterAdded = false;


	/**
	 * Broadcast the received message object to all suspended response. Do not write back the message to the calling connection.
	 *
	 */
	@Message(encoders = {JacksonEncoder.class}/*, decoders = {JacksonEncoder.class}*/)
	public AtmosphereMessage onMessage(AtmosphereMessage atmosphereMessage) {
		logger.debug("sending {} ", atmosphereMessage.toString());
		return atmosphereMessage;
	}


	/**
	 * generic wrapper to Broadcaster.broadcast()
	 * this method should be called when an event has happened that needs to be broadcasted to the clients
	 */
	public static void broadcast(AtmosphereMessage msg) {
		if(staticFactory != null) {
			Broadcaster b = staticFactory.lookup("/", true);
			if (!_filterAdded) {
				b.getBroadcasterConfig().addFilter(new CheckSessionJobFilter());
				_filterAdded = true;
			}
			b.broadcast(msg);
		}
	}

	/** very generic wrapper to Braodcaster.broadcast()
	 *  	this method should be called when an event has happened that needs to be broadcasted to the clients */
	public static void broadcast(AtmosphereChannel channel, String event, Map<String, Object> content) {
		broadcast(new AtmosphereMessage(channel, event, content));
	}

	public static void broadcast(AtmosphereChannel channel) {
		broadcast(new AtmosphereMessage(channel, channel.name()));
	}


	private static class CheckSessionJobFilter implements PerRequestBroadcastFilter {

		@Override
		public BroadcastAction filter(
				String broadcasterId, Object originalMessage, Object message) {
			return new BroadcastAction(BroadcastAction.ACTION.CONTINUE, message);
		}

		@Override
		public BroadcastAction filter(
				String broadcasterId, AtmosphereResource resource,
				Object originalMessage, Object message) {

			if (message instanceof JobStatusMessage jobMsg) {
				var session = resource.getRequest().getSession();
				long jobId = (long) jobMsg.getContent().get("id");
				var isSessionJob = SessionUtil.containsJob(session, jobId);
				if (isSessionJob) {
					return new BroadcastAction(
							BroadcastAction.ACTION.CONTINUE, jobMsg.sessionJobCopy());
				}
			}
			return new BroadcastAction(BroadcastAction.ACTION.CONTINUE, message);
		}
	}
}