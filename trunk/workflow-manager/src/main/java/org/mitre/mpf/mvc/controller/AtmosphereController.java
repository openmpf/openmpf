/******************************************************************************
 * NOTICE                                                                     *
 *                                                                            *
 * This software (or technical data) was produced for the U.S. Government     *
 * under contract, and is subject to the Rights in Data-General Clause        *
 * 52.227-14, Alt. IV (DEC 2007).                                             *
 *                                                                            *
 * Copyright 2017 The MITRE Corporation. All Rights Reserved.                 *
 ******************************************************************************/

/******************************************************************************
 * Copyright 2017 The MITRE Corporation                                       *
 *                                                                            *
 * Licensed under the Apache License, Version 2.0 (the "License");            *
 * you may not use this file except in compliance with the License.           *
 * You may obtain a copy of the License at                                    *
 *                                                                            *
 *    http://www.apache.org/licenses/LICENSE-2.0                              *
 *                                                                            *
 * Unless required by applicable law or agreed to in writing, software        *
 * distributed under the License is distributed on an "AS IS" BASIS,          *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
 * See the License for the specific language governing permissions and        *
 * limitations under the License.                                             *
 ******************************************************************************/

package org.mitre.mpf.mvc.controller;

import java.util.HashMap;
import java.util.concurrent.ConcurrentHashMap;

import javax.inject.Inject;

import org.atmosphere.config.service.Disconnect;
import org.atmosphere.config.service.ManagedService;
import org.atmosphere.config.service.Message;
import org.atmosphere.config.service.Ready;
import org.atmosphere.cpr.AtmosphereResource;
import org.atmosphere.cpr.AtmosphereResourceEvent;
import org.atmosphere.cpr.Broadcaster;
import org.atmosphere.cpr.BroadcasterFactory;
import org.mitre.mpf.mvc.JacksonEncoder;
import org.mitre.mpf.mvc.model.AtmosphereChannel;
import org.mitre.mpf.mvc.model.AtmosphereMessage;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *  Workflow manager uses Atmosphere (https://github.com/Atmosphere/atmosphere) for asynchronous communication
 *  to clients, referred to here as Server Side Push.  This is an event-based approach where
 *  events are generated by workflow-manager, packaged as AtmosphereMessage messages, and broadcasted to all
 *  logged in clients.  The Atmosphere package prefers websockets as the underlying mechanism for communication,
 *  but will intelligently downgrade to comet and other mechanisms if the client does not support websockets.
 *
 *  This approach simplifies and unifies messaging from server to client, provides for a consistent messaging bundle
 *  among components, and significantly decreases the network traffic when using modern browsers. 
 *
 *  Workflow manager messages are divided into channels, as specified in 
 *  org.mitre.mpf.mvc.model.AtmosphereChannel.  Clients use $on(...) handlers to react to server notifications.
 *  
 *  An AtmosphereMessage looks like the following (in JSON)
 *		{
 *			"channel": "SSPC_ATMOSPHERE",
 *			"event": "OnConnected",
 *			"timestamp": 1453350363907,
 *			"content": {
 *				"abc": "1",
 *				"xyz": "2"
 *			}
 *		}
 *	Note that the content can be any arbitrary Java HashMap, making it easy to encode any data as key/value pairs.
 *	Typical for JSON messaging, each message author designs her own semantics for the message content, and
 *	each client will need to understand the intended semantic.
 *
 *  The reason that we have channels and then events in the channels, instead of events directly
 *  is that this promotes events that have more consistent semantic meaning among its peers in the same channel.
 *  Also, it enables similar code to be contained within the same handler on the client side.
 *  
 *  However, not all channels have events (e.g., SSPC_HEARTBEAT) so you should check for null first when accessing events.
 *
 */
@ManagedService(path = "/") //points to websocket/ seen in web.xml
public class AtmosphereController {
	private final Logger logger = LoggerFactory.getLogger(AtmosphereController.class);

	private final ConcurrentHashMap<String, String> users = new ConcurrentHashMap<String, String>();

//	@Inject
//	private BroadcasterFactory factory;

	@Inject
	private static BroadcasterFactory staticFactory;

//	@Inject
//	private AtmosphereResourceFactory resourceFactory;

//	@Inject
//	private MetaBroadcaster metaBroadcaster;

	/**
	 * Invoked when the connection as been fully established and suspended, e.g ready for receiving messages.
	 *
	 */
	@Ready(encoders = {JacksonEncoder.class}) 
	//@DeliverTo(DeliverTo.DELIVER_TO.ALL)
	public AtmosphereMessage onReady(AtmosphereResource r) {
		logger.debug("Browser {} connected to websocket.", r.uuid());
		HashMap<String, String> data = new HashMap<>();
		data.put("uuid", r.uuid());
		data.put("transport", r.transport().toString());
		data.put("message", "server side push ready");
		return new AtmosphereMessage( AtmosphereChannel.SSPC_ATMOSPHERE, "OnConnected", data );
	}

	/**
	 * Broadcast the received message object to all suspended response. Do not write back the message to the calling connection.
	 *
	 */
	@Message(encoders = {JacksonEncoder.class}/*, decoders = {JacksonEncoder.class}*/)
	public AtmosphereMessage onMessage(AtmosphereMessage atmosphereMessage) {
//		atmosphereMessage.setTimestamp(new Date());
		logger.debug("sending {} ", atmosphereMessage.toString());
		return atmosphereMessage;
	} 

	/**
	 * Invoked when the client disconnect or when an unexpected closing of the underlying connection happens. 
	 *
	 */
	@Disconnect
    public void onDisconnect(AtmosphereResourceEvent event) {
		if (event.isCancelled()) {
			// We didn't get notified, so we remove the user.
			users.values().remove(event.getResource().uuid());
			logger.debug("Browser {} unexpectedly disconnected", event.getResource().uuid());
		} else if (event.isClosedByClient()) {
			logger.debug("Browser {} closed the connection", event.getResource().uuid());
		}
	}

	/**
	 * generic wrapper to Braodcaster.broadcast()
	 * this method should be called when an event has happened that needs to be broadcasted to the clients
	 */
	public static void broadcast(AtmosphereMessage msg) {
		if(staticFactory != null) {
			//Broadcaster b = staticFactory.lookup("/*");
			Broadcaster b = staticFactory.lookup("/");
			if(b == null) {
				//b = staticFactory.get("/*");
				b = staticFactory.get("/");
			}
			b.broadcast(msg);
		}
	}
	
	/** very generic wrapper to Braodcaster.broadcast()
	 *  	this method should be called when an event has happened that needs to be broadcasted to the clients */
	public static void broadcast(AtmosphereChannel channel, String event, HashMap content) {
		broadcast(new AtmosphereMessage(channel, event, content));
	}

}