/******************************************************************************
 * NOTICE                                                                     *
 *                                                                            *
 * This software (or technical data) was produced for the U.S. Government     *
 * under contract, and is subject to the Rights in Data-General Clause        *
 * 52.227-14, Alt. IV (DEC 2007).                                             *
 *                                                                            *
 * Copyright 2024 The MITRE Corporation. All Rights Reserved.                 *
 ******************************************************************************/

/******************************************************************************
 * Copyright 2024 The MITRE Corporation                                       *
 *                                                                            *
 * Licensed under the Apache License, Version 2.0 (the "License");            *
 * you may not use this file except in compliance with the License.           *
 * You may obtain a copy of the License at                                    *
 *                                                                            *
 *    http://www.apache.org/licenses/LICENSE-2.0                              *
 *                                                                            *
 * Unless required by applicable law or agreed to in writing, software        *
 * distributed under the License is distributed on an "AS IS" BASIS,          *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
 * See the License for the specific language governing permissions and        *
 * limitations under the License.                                             *
 ******************************************************************************/


package org.mitre.mpf.wfm.service;

import java.util.Map;
import java.util.OptionalInt;
import java.util.UUID;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import javax.inject.Inject;

import org.apache.camel.Message;
import org.mitre.mpf.rest.api.pipelines.Action;
import org.mitre.mpf.wfm.data.entities.persistent.BatchJob;
import org.mitre.mpf.wfm.data.entities.persistent.Media;
import org.mitre.mpf.wfm.data.entities.transients.Track;
import org.mitre.mpf.wfm.enums.MpfConstants;
import org.mitre.mpf.wfm.util.AggregateJobPropertiesUtil;
import org.springframework.stereotype.Component;


@Component
public class TaskAnnotatorService {

    private static final String BREAD_CRUMB_HEADER = "breadcrumbId";

    // Camel will automatically add a bread crumb if one is not included in the message headers.
    // Adding a prefix to the bread crumb makes it possible to identify which bread crumbs were
    // added by this class.
    private static final String CUSTOM_BREAD_CRUMB_PREFIX = "mpf-";


    private final AggregateJobPropertiesUtil _aggregateJobPropertiesUtil;


    @Inject
    TaskAnnotatorService(
            AggregateJobPropertiesUtil aggregateJobPropertiesUtil) {
        _aggregateJobPropertiesUtil = aggregateJobPropertiesUtil;
    }


    public boolean needsBreadCrumb(BatchJob job, Media media, int taskIdx, int actionIdx) {
        return getTransitiveAnnotatedTasks(job, media, taskIdx, actionIdx)
                .min()
                .stream()
                .mapToObj(ti -> job.getPipelineElements().getAction(ti, 0))
                .anyMatch(a -> actionHasTrigger(job, media, a));
    }


    // When creating detection request messages for an action that has an annotator and the
    // transitive task uses a trigger, the tracks that are fed in to the action may have
    // initially been generated by different algorithms. In those cases, we store name of the
    // algorithm that was originally used to generate the feed forward track in the breadcrumbId
    // header.
    public void addBreadCrumb(
            Message message, Track feedForwardTrack) {
        message.setHeader(
                BREAD_CRUMB_HEADER,
                CUSTOM_BREAD_CRUMB_PREFIX + feedForwardTrack.getAnnotatedTaskIndex()
                        + '-' + UUID.randomUUID());
    }


    public int getAnnotatedTaskIndex(
            BatchJob job,
            Media media,
            int taskIdx,
            int actionIdx,
            Map<String, Object> headers) {
        var headerTaskIdx = parseBreadCrumb(headers);
        if (headerTaskIdx.isPresent()) {
            return headerTaskIdx.getAsInt();
        }
        return getTransitiveAnnotatedTasks(job, media, taskIdx, actionIdx)
                // Annotator property is enabled, so use the task at the end of the chain.
                .min()
                // Annotator property wasn't enabled, so use the actual task.
                .orElse(taskIdx);
    }


    private OptionalInt parseBreadCrumb(Map<String, Object> headers) {
        if (!(headers.get(BREAD_CRUMB_HEADER) instanceof String breadcrumbHeader)) {
            return OptionalInt.empty();
        }
        if (!breadcrumbHeader.startsWith(CUSTOM_BREAD_CRUMB_PREFIX)) {
            return OptionalInt.empty();
        }
        var headerNoPrefix = breadcrumbHeader.substring(CUSTOM_BREAD_CRUMB_PREFIX.length());
        var taskIdxStr = headerNoPrefix.split("-", 2)[0];
        try {
            return OptionalInt.of(Integer.parseInt(taskIdxStr));
        }
        catch (NumberFormatException e) {
            return OptionalInt.empty();
        }
    }


    public boolean isAnnotatorAction(BatchJob job, Media media, int taskIdx, int actionIdx) {
        if (taskIdx == 0) {
            return false;
        }
        var action = job.getPipelineElements().getAction(taskIdx, actionIdx);
        return isAnnotatorAction(job, media, action);
    }


    private boolean isAnnotatorAction(BatchJob job, Media media, Action action) {
        var annotatorProperty = _aggregateJobPropertiesUtil.getValue(
                MpfConstants.IS_ANNOTATOR_PROPERTY, job, media, action);
        return Boolean.parseBoolean(annotatorProperty);
    }


    public boolean taskHasAnnotator(BatchJob job, Media media, int taskIdx) {
        var pipelineElements = job.getPipelineElements();
        int lastDetectionTaskIdx = pipelineElements.getLastDetectionTaskIdx();

        for (int futureTaskIdx = taskIdx + 1;
                futureTaskIdx <= lastDetectionTaskIdx;
                futureTaskIdx++) {
            var futureTask = pipelineElements.getTask(futureTaskIdx);
            var taskAppliesToMedia = false;
            var taskHasTrigger = false;
            for (var futureAction : pipelineElements.getActionsInOrder(futureTask)) {
                if (_aggregateJobPropertiesUtil.actionAppliesToMedia(job, media, futureAction)) {
                    taskAppliesToMedia = true;
                    if (isAnnotatorAction(job, media, futureAction)) {
                        return true;
                    }
                    taskHasTrigger = taskHasTrigger || actionHasTrigger(job, media, futureAction);
                }
            }
            if (taskAppliesToMedia && !taskHasTrigger) {
                return false;
            }
        }
        return false;
    }

    private boolean actionHasTrigger(BatchJob job, Media media, Action action) {
        var trigger = _aggregateJobPropertiesUtil.getValue(
                MpfConstants.TRIGGER, job, media, action);
        return trigger != null && !trigger.isBlank();
    }

    public IntStream getTransitiveAnnotatedTasks(
            BatchJob job, Media media, int srcTaskIdx, int srcActionIdx) {
        return Stream.iterate(
                getDirectAnnotatedTask(job, media, srcTaskIdx, srcActionIdx),
                OptionalInt::isPresent,
                p -> getDirectAnnotatedTask(job, media, p.getAsInt(), 0))
            .mapToInt(OptionalInt::getAsInt);
    }


    private OptionalInt getDirectAnnotatedTask(
            BatchJob job, Media media, int srcTaskIdx, int srcActionIdx) {
        if (!isAnnotatorAction(job, media, srcTaskIdx, srcActionIdx)) {
            return OptionalInt.empty();
        }

        for (int prevTaskIdx = srcTaskIdx - 1; prevTaskIdx >= 0; prevTaskIdx--) {
            var prevAction = job.getPipelineElements().getAction(prevTaskIdx, 0);
            if (_aggregateJobPropertiesUtil.actionAppliesToMedia(job, media, prevAction)) {
                return OptionalInt.of(prevTaskIdx);
            }
        }
        return OptionalInt.of(0);
    }
}
