/******************************************************************************
 * NOTICE                                                                     *
 *                                                                            *
 * This software (or technical data) was produced for the U.S. Government     *
 * under contract, and is subject to the Rights in Data-General Clause        *
 * 52.227-14, Alt. IV (DEC 2007).                                             *
 *                                                                            *
 * Copyright 2024 The MITRE Corporation. All Rights Reserved.                 *
 ******************************************************************************/

/******************************************************************************
 * Copyright 2024 The MITRE Corporation                                       *
 *                                                                            *
 * Licensed under the Apache License, Version 2.0 (the "License");            *
 * you may not use this file except in compliance with the License.           *
 * You may obtain a copy of the License at                                    *
 *                                                                            *
 *    http://www.apache.org/licenses/LICENSE-2.0                              *
 *                                                                            *
 * Unless required by applicable law or agreed to in writing, software        *
 * distributed under the License is distributed on an "AS IS" BASIS,          *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
 * See the License for the specific language governing permissions and        *
 * limitations under the License.                                             *
 ******************************************************************************/


package org.mitre.mpf.wfm.service;

import static java.util.stream.Collectors.joining;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.Predicate;
import java.util.stream.Stream;

import javax.inject.Inject;

import org.apache.camel.Message;
import org.mitre.mpf.rest.api.pipelines.Action;
import org.mitre.mpf.wfm.data.entities.persistent.BatchJob;
import org.mitre.mpf.wfm.data.entities.persistent.Media;
import org.mitre.mpf.wfm.data.entities.transients.Track;
import org.mitre.mpf.wfm.segmenting.TriggerProcessor;
import org.mitre.mpf.wfm.util.AggregateJobPropertiesUtil;
import org.springframework.stereotype.Component;


@Component
public class TaskAnnotatorService {

    private static final String BREAD_CRUMB_HEADER = "breadcrumbId";

    private static final String IS_ANNOTATOR_PROPERTY = "IS_ANNOTATOR";

    // Camel will automatically add a bread crumb if one is not included in the message headers.
    // Adding a prefix to the bread crumb makes it possible to identify which bread crumbs were
    // added by this class.
    private static final String CUSTOM_BREAD_CRUMB_PREFIX = "mpf-";

    private final AggregateJobPropertiesUtil _aggregateJobPropertiesUtil;

    private final TriggerProcessor _triggerProcessor;


    @Inject
    TaskAnnotatorService(
            AggregateJobPropertiesUtil aggregateJobPropertiesUtil,
            TriggerProcessor triggerProcessor) {
        _aggregateJobPropertiesUtil = aggregateJobPropertiesUtil;
        _triggerProcessor = triggerProcessor;
    }

    public boolean actionIsAnnotator(BatchJob job, Media media, int taskIdx, int actionIdx) {
        if (taskIdx == 0) {
            return false;
        }
        var action = job.getPipelineElements().getAction(taskIdx, actionIdx);
        return _aggregateJobPropertiesUtil.getBool(IS_ANNOTATOR_PROPERTY, job, media, action);
    }

    public boolean needsBreadCrumb(BatchJob job, Media media, int taskIdx, int actionIdx) {
        return actionIsAnnotator(job, media, taskIdx, actionIdx);
    }


    // When creating detection request messages for an action that has an annotator and the
    // transitive task uses a trigger, the tracks that are fed in to the action may have
    // initially been generated by different algorithms. In those cases, we store name of the
    // algorithm that was originally used to generate the feed forward track in the breadcrumbId
    // header.
    public void addBreadCrumb(
            Message message, Track feedForwardTrack) {
        var joinedIndices = Stream.concat(
                Stream.of(feedForwardTrack.getTaskIndex()),
                feedForwardTrack.getAnnotatedTaskIndices().stream())
            .distinct()
            .sorted()
            .map(String::valueOf)
            .collect(joining(";"));

        message.setHeader(
                BREAD_CRUMB_HEADER,
                CUSTOM_BREAD_CRUMB_PREFIX + joinedIndices + '-' + UUID.randomUUID());
    }


    public static List<Integer> getAnnotatedTaskIndices(Map<String, Object> headers) {
        if (!(headers.get(BREAD_CRUMB_HEADER) instanceof String breadcrumbHeader)) {
            return List.of();
        }
        if (!breadcrumbHeader.startsWith(CUSTOM_BREAD_CRUMB_PREFIX)) {
            return List.of();
        }
        var headerNoPrefix = breadcrumbHeader.substring(CUSTOM_BREAD_CRUMB_PREFIX.length());
        var taskIndices = headerNoPrefix.split("-", 2)[0];
        try {
            return Stream.of(taskIndices.split(";"))
                .map(Integer::parseInt)
                .toList();
        }
        catch (NumberFormatException e) {
            return List.of();
        }
    }


    public Predicate<Track> createIsAnnotatedChecker(BatchJob job, Media media) {
        var triggerCache = new TriggerCache(job, media);
        return track -> isAnnotated(job, media, track, triggerCache);
    }


    private boolean isAnnotated(BatchJob job, Media media, Track track, TriggerCache triggerCache) {
        return getNextActions(job, media, track, triggerCache)
            .anyMatch(a -> _aggregateJobPropertiesUtil.getBool(
                    IS_ANNOTATOR_PROPERTY, job, media, a));
    }

    private Stream<Action> getNextActions(
            BatchJob job, Media media, Track track, TriggerCache triggerCache) {
        var pipelineElements = job.getPipelineElements();
        int lastDetectionTaskIdx = pipelineElements.getLastDetectionTaskIdx();
        if (track.getTaskIndex() >= lastDetectionTaskIdx) {
            return Stream.of();
        }


        Predicate<Action> wasInput = a ->
                _aggregateJobPropertiesUtil.actionAppliesToMedia(job, media, a)
                && triggerCache.isTriggered(a, track);

        for (int i = track.getTaskIndex() + 1; i < lastDetectionTaskIdx; i++) {
            var action = pipelineElements.getAction(i, 0);
            if (wasInput.test(action)) {
                return Stream.of(action);
            }
        }

        var lastDetectionTask = pipelineElements.getTask(lastDetectionTaskIdx);
        return pipelineElements.getActionStreamInOrder(lastDetectionTask)
            .filter(wasInput);
    }

    private class TriggerCache {

        private final Map<String, Predicate<Track>> _cache = new HashMap<>();

        private final BatchJob _job;

        private final Media _media;

        public TriggerCache(BatchJob job, Media media) {
            _job = job;
            _media = media;
        }

        public boolean isTriggered(Action action, Track track) {
            var pred = _cache.computeIfAbsent(
                    action.name(),
                    k -> _triggerProcessor.createActionTrigger(_job, _media, action));
            return pred.test(track);
        }
    }
}
